A very tiny VM is used to execute byte code. And byte code are generated on the fly while parsing. We don't have any intermiedate representation of our source code.

Sample:

{% for some_data in map %}
  {% do some_var.append(some_data) %}
{% endfor %}

The above code is a for loop. To compile this we need to figure out offset for us to jmp to end of the loop, say this value  is alwasy known during the compilation phase, let's say it to be 100.

Then we will generate code like this:

Suppose constant table is like this:
[some_data,some_var,map,append]

VM_LVAR(2)     ; Load map object into the stack
VM_ITR_BEG     ; Set up the loop for map object , this will result in
               ; the length of map on stack , and the index set to zero on stack as well.
               ; After execution of the above 3 instructions, the stack will look like this:
               ; [ map , 10 , 0] Suppose map has 10 elements.
VM_ITR_TEST(100); Test stack(#) and stack(#-1) ; if not pass jump to 100
VM_ENTER       ; Enter the scope, create a new scope
VM_ITR_DEREF(-2) 
               ; Derefence the current iterator on object , this result in the top 2 elements resolved into
               ; one object on top of the stack, stack : [map,10,0,index_0_value]
VM_SVAR(0)     ; Set up the local variable, resolve the top element. Now stack looks like this:
               ; [map,10,0]
; --------------------- do code part ------------------------------
VM_LVAR(1)     ; Look up variable has name in constant table with index 1.
               ; [map,10,0,some_var]
VM_LVAR(0)     ; Look up variable has name in constant table with index 0.
               ; [map,10,0,some_var,some_data]
VM_LIMM(1)     ; Load parameter count 1
VM_CALL(3)     ; Call function "append" on object .
               ; stack: [map,10,0,some_var,some_data,1]
               ; After calling done, stack will become something like:
               ; [map,10,0,result]
VM_POP         ; Pop the result from stack since no assignment is made here
VM_ITR_MOVE(-2); Move the interator
VM_RESET       ; Reset the local stack since they are done actually
VM_JMP(VM_ENTER); Jmp to VM_ENTER and do the loop again
; ------------------- lable:100 ---------------------------
; DONE , and now stack is empty at all

